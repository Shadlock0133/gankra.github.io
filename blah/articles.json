{
    "articles": [
         { "path": "deinitialize-me-maybe", "toc": true, "title": "Destroy All Values: Designing Deinitialization in Programming Languages" },
        { "path": "compact-unwinding", "toc": true, "title": "The Apple Compact Unwinding Format: Documented and Explained" },
        { "path": "swift-abi", "toc": true, "title": "How Swift Achieved Dynamic Linking Where Rust Couldn't" },
        { "path": "text-hates-you", "toc": false, "title": "Text Rendering Hates You" },
        { "path": "hashbrown-tldr", "toc": false, "title": "Swisstable, a Quick and Dirty Description" },
        { "path": "hashbrown-insert", "toc": false, "title": "Why Hashbrown Does A Double-Lookup" },
        { "path": "initialize-me-maybe", "toc": false, "title": "Here's My Type, So Initialize Me Maybe" },
        { "path": "impl-defined", "toc": false, "title": "The Kinds of Implementation-Defined?" },
        { "path": "rust-layouts-and-abis", "toc": true, "title": "Notes on Type Layouts and ABIs in Rust" },
        { "path": "only-in-rust", "toc": false, "title": "Bugs You'll Probably Only Have In Rust" },
        { "path": "linear-rust", "toc": true, "title": "The Pain Of Linear Types In Rust" },
        { "path": "robinhood-part-1", "toc": false, "title": "A HashMap in Rust - What's a HashMap?" },
        { "path": "rust-btree-case", "toc": false, "title": "Rust Collections Case Study: BTreeMap" },
        { "path": "rust-generics-and-collections", "toc": false, "title": "Rust, Generics, and Collections" },
        { "path": "everyone-poops", "toc": false, "title": "Pre-Pooping Your Pants With Rust" },
        { "path": "rust-lifetimes-and-collections", "toc": false, "title": "Rust, Lifetimes, and Collections" },
        { "path": "homestuck-memories", "toc": false, "title": "Memories of Working on Homestuck" }
    ]
}




